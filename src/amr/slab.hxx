#ifndef _8a82edcb_29c9_4f39_95bc_21eb77e0bd32
#define _8a82edcb_29c9_4f39_95bc_21eb77e0bd32

# include "boundary.hxx"
# include "expr.hxx"
# include "boxlist.hxx"
# include "boxmap.hxx"
# include "boxtree.hxx"

# include "perfmodel/perfmodel.hxx"

# include <new>

namespace programr {
namespace amr {
  struct Slab: Result {
    Ref<Boundary> bdry;
    boxtree::Level level;
    int halo_n;
    Ref<Data> data;
    Imm<BoxMap<int>> rank_map;
    std::size_t elmt_sz;
    
    // generated by tasks()
    Ref<BoxMap<std::uint64_t>> task_map;
  
    // Result:
    void datas(std::vector<Data*> &add_to) const;
    void tasks(std::vector<std::uint64_t> &add_to) const;
  };
  
  struct Expr_Slab: Expr {
    Expr_Slab(SourceLocation loc): Expr(loc) {}
  };
  
  
  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Literal
  
  struct Expr_Slab_Literal: Expr_Slab {
    std::string note;
    Expr_Slab_Literal(SourceLocation loc): Expr_Slab(loc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_literal_(
      SourceLocation sloc,
      Ref<Boundary> bdry,
      const boxtree::Level &level,
      Imm<BoxMap<int>> rank_map,
      std::size_t elmt_sz,
      std::string note={}
    ) {
    
    Slab *res = new Slab;
    res->bdry = std::move(bdry);
    res->level = level;
    res->halo_n = 0;
    res->data = new Data;
    res->rank_map = std::move(rank_map);
    res->elmt_sz = elmt_sz;
    
    Expr_Slab_Literal *e = new Expr_Slab_Literal(sloc);
    e->result = res;
    e->note = std::move(note);
    
    return e;
  }
  
# define slab_literal(...) programr::amr::slab_literal_(_SLOC_, __VA_ARGS__)
  

  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Migrate
  
  struct Expr_Slab_Migrate: Expr_Slab {
    Ex<Slab> x;
    Imm<BoxMap<int>> new_ranks;
    std::string note;
    
    Expr_Slab_Migrate(SourceLocation loc): Expr_Slab(loc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_migrate_(
      SourceLocation sloc,
      Ex<Slab> x,
      Imm<BoxMap<int>> new_ranks,
      std::string note={}
    ) {
    
    Expr_Slab_Migrate *e = new Expr_Slab_Migrate(sloc);
    
    e->x = std::move(x);
    e->new_ranks = std::move(new_ranks);
    e->note = std::move(note);
    
    return e;
  }

# define slab_migrate(...) programr::amr::slab_migrate_(_SLOC_, __VA_ARGS__)

  
  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Op
  
  struct Expr_Slab_Op: Expr_Slab {
    RefBoxed<Ex<Slab>[]> args;
    std::size_t elmt_sz;
    std::string note;
    double perf_wflops = 0.0;
    
    Expr_Slab_Op(SourceLocation loc): Expr_Slab(loc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_op_(
      SourceLocation sloc,
      std::initializer_list<Ex<Slab>> args,
      std::size_t elmt_sz = std::size_t(-1),
      std::string note={},
      double perf_wflops=0.0
    ) {
    DEV_ASSERT(args.size() > 0);
    
    Expr_Slab_Op *e = new Expr_Slab_Op(sloc);
    
    e->args.alloc(
      args.size(),
      [&](int i, void *p) {
        ::new(p) Ex<Slab>(args.begin()[i]);
      }
    );
    e->elmt_sz = elmt_sz;
    e->note = std::move(note);
    e->perf_wflops = perf_wflops;
    
    return e;
  }

# define slab_op(...) programr::amr::slab_op_(_SLOC_, __VA_ARGS__)

  
  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Halo
  
  struct Expr_Slab_Halo: Expr_Slab {
    Ex<Slab> kid, par;
    int halo_n;
    int prolong_halo_n;
    std::string note;
    
    Expr_Slab_Halo(SourceLocation sloc): Expr_Slab(sloc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_halo_(
      SourceLocation sloc,
      Ex<Slab> kid,
      Ex<Slab> par,
      int halo_n,
      int prolong_halo_n=0,
      std::string note={}
    ) {
    Expr_Slab_Halo *e = new Expr_Slab_Halo(sloc);
    e->kid = kid;
    e->par = par;
    e->halo_n = halo_n;
    e->prolong_halo_n = prolong_halo_n;
    e->note = std::move(note);
    return e;
  }

# define slab_halo(...) programr::amr::slab_halo_(_SLOC_, __VA_ARGS__)

  
  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Halo2
  
  struct Expr_Slab_Halo2: Expr_Slab {
    Ex<Slab> kid, par0, par1;
    int halo_n;
    int prolong_halo_n;
    std::string note;
    
    Expr_Slab_Halo2(SourceLocation sloc): Expr_Slab(sloc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_halo2_(
      SourceLocation sloc,
      Ex<Slab> kid,
      Ex<Slab> par0,
      Ex<Slab> par1,
      int halo_n, int prolong_halo_n=0,
      std::string note={}
    ) {
    Expr_Slab_Halo2 *e = new Expr_Slab_Halo2(sloc);
    e->kid = std::move(kid);
    e->par0 = std::move(par0);
    e->par1 = std::move(par1);
    e->halo_n = halo_n;
    e->prolong_halo_n = prolong_halo_n;
    e->note = std::move(note);
    return e;
  }

# define slab_halo2(...) programr::amr::slab_halo2_(_SLOC_, __VA_ARGS__)

  
  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Stencil
  
  struct Expr_Slab_Stencil: Expr_Slab {
    Ex<Slab> x;
    int halo_n;
    std::string note;
    perf::Stencil3DParams perf_stencil;
    
    Expr_Slab_Stencil(SourceLocation sloc): Expr_Slab(sloc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_stencil_(
      SourceLocation sloc,
      Ex<Slab> x,
      int halo_n,
      std::string note={},
      perf::Stencil3DParams perf_stencil=perf::Stencil3DParams::nop()
    ) {
    Expr_Slab_Stencil *e = new Expr_Slab_Stencil(sloc);
    e->x = std::move(x);
    e->halo_n = halo_n;
    e->note = std::move(note);
    e->perf_stencil = perf_stencil;
    return e;
  }
  
# define slab_stencil(...) programr::amr::slab_stencil_(_SLOC_, __VA_ARGS__)

  
  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Restrict
  
  struct Expr_Slab_Restrict: Expr_Slab {
    Ex<Slab> par;
    Ex<Slab> kid;
    bool reflux;
    std::string note;
    perf::Stencil3DParams perf_stencil;
    
    Expr_Slab_Restrict(SourceLocation sloc): Expr_Slab(sloc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_restrict_(
      SourceLocation sloc,
      Ex<Slab> par,
      Ex<Slab> kid,
      bool reflux=false,
      std::string note={},
      perf::Stencil3DParams perf_stencil=perf::Stencil3DParams::nop()
    ) {
    Expr_Slab_Restrict *e = new Expr_Slab_Restrict(sloc);
    e->par = std::move(par);
    e->kid = std::move(kid);
    e->reflux = reflux;
    e->perf_stencil = perf_stencil;
    e->note = std::move(note);
    return e;
  }
  
  inline Ex<Slab> slab_restrict_reflux_(
      SourceLocation sloc,
      Ex<Slab> par,
      Ex<Slab> kid,
      std::string note={},
      perf::Stencil3DParams perf_stencil=perf::Stencil3DParams::nop()
    ) {
    return slab_restrict_(sloc, std::move(par), std::move(kid), true, std::move(note), perf_stencil);
  }
  
# define slab_restrict(...) programr::amr::slab_restrict_(_SLOC_, __VA_ARGS__)
# define slab_restrict_reflux(...) programr::amr::slab_restrict_reflux_(_SLOC_, __VA_ARGS__)


  //////////////////////////////////////////////////////////////////////
  // Expr_Slab_Prolong
  
  struct Expr_Slab_Prolong: Expr_Slab {
    Ex<Slab> kid;
    Ex<Slab> par;
    int prolong_halo_n;
    std::string note;
    perf::Stencil3DParams perf_stencil;
    
    Expr_Slab_Prolong(SourceLocation sloc): Expr_Slab(sloc) {}
    
    // Expr:
    void subexs(std::vector<Expr*> &add_to) const;
    void show(std::ostream &o) const;
    void execute(ExecCxt &cxt);
  };
  
  inline Ex<Slab> slab_prolong_(
      SourceLocation sloc,
      Ex<Slab> kid,
      Ex<Slab> par,
      int prolong_halo_n=0,
      std::string note={},
      perf::Stencil3DParams perf_stencil=perf::Stencil3DParams::nop()
    ) {
    Expr_Slab_Prolong *e  = new Expr_Slab_Prolong(sloc);
    e->kid = std::move(kid);
    e->par = std::move(par);
    e->prolong_halo_n = prolong_halo_n;
    e->note = std::move(note);
    e->perf_stencil = perf_stencil;
    return e;
  }

# define slab_prolong(...) programr::amr::slab_prolong_(_SLOC_, __VA_ARGS__)

  void print_slab_counters();
}}
#endif
